See https://perl2java.wordpress.com/2013/07/12/a-perl2java-tool-the-approach

The example runs with:

perl yappie.pl test.pl

or use 

make test 

after a change of the compiler.

The semantic actions are in JavaGenerator.pm, the main part of the work is done by JV_GEN_call that is called from the generated parser when it recognizes a statement.

The Log.pm module helps you with the Log::debug statements to see whatâ€™s going on, you can add more when you really want to understand more details.

In general you would need some (very) good knowledge on Java, Perl and how you build language compilers in general which is not always the most simple task.

The current compiler can compile this very simple perl program, its currently the most complex it can do, more complicated perl will probably make it crash or generate Java code that you cannot compile.

One idea I also had was perhaps partial use automated compilation and that do the rest manual, however that only works with a limited amount of perl code.

# yappie.pl Documentation

This Perl script `yappie.pl` uses Parse::Lex and Parse::Yapp to parse a Perl file and generate equivalent Java code.  It leverages several other modules for functionality such as Java code generation, logging, and data manipulation.

## Functionality

`yappie.pl` takes a Perl source file as input and performs the following actions:

1. **Lexical Analysis:** Uses `initialize_lexer` to create a lexer using `Parse::Lex`. This lexer breaks down the Perl code into tokens.  The lexer is customized to handle Perl-specific keywords and constructs.  It skips whitespace and includes custom handling for subroutines.

2. **Parsing:** Employs a `PerlParser` (not included in this documentation) to parse the token stream generated by the lexer. This parser uses a Yacc-like grammar to structure the code into a parse tree.

3. **Code Generation:** A `JavaGenerator` (documented separately) translates the parsed Perl code into Java code.  This involves transforming Perl constructs into their Java equivalents and handling Perl-specific features like subroutines and variable declarations.

4. **Output:** The generated Java code is written to a new `.java` file.  A log message confirms the successful file generation.

## Modules Used

* **`Parse::Lex`:** For lexical analysis (tokenizing).
* **`Parse::Yapp`:** For parsing the token stream.
* **`PerlParser`:** A custom parser (code not included).
* **`JavaGenerator`:** A custom module for generating Java code (documented below).
* **`Data::Dumper`:** For debugging (likely used internally).
* **`Log`:** For logging information and errors (a custom logging module).


## Debugging Flags

The `DEBUG` constant controls the level of debugging output.  Bit values control different aspects of the debugging output:

* `0x01`: Token reading (lexer debugging).
* `0x02`: States information (parser).
* `0x04`: Driver actions (shifts, reduces, accept).
* `0x08`: Parse stack dump.
* `0x10`: Error recovery tracing.

Currently, `DEBUG` is set to `0x0`, disabling debugging output.


##  Lexicon and Tokenization

The script defines a regular expression-based lexicon (`@token`) to recognize different tokens in the Perl input.  The lexicon includes rules for keywords, operators, identifiers, and whitespace.  A custom error handling rule is also included.

## Error Handling

The `error_sub` function handles parsing errors. It reports the error and exits the script if a parsing error occurs outside of the end-of-input.

## Main Function (`main`)

The `main` function orchestrates the entire process:

1. Takes the input Perl filename as a command-line argument.
2. Initializes the lexer.
3. Creates a `PerlParser` and `JavaGenerator` instance.
4. Calls `YYParse` to perform the parsing.
5. Generates the Java code using `JavaGenerator`.
6. Writes the generated Java code to a file.
7. Logs a success message.


# JavaGenerator.pm Documentation

This Perl module provides the functionality to generate Java code from the parsed Perl code.

## Class Methods

* **`new(%param)`:** Constructor. Takes a hash of parameters:
    * `parser`: The `PerlParser` instance.
    * `lexer`: The `Parse::Lex` lexer instance.
    * `perl_filename`: The name of the input Perl file.
    * `java_filename`: The name of the output Java file.
    * `java_classname`: The name of the Java class to generate.
    * `java_package`:  The Java package name.
    * `perl_sublist`:  An array of built-in Perl subroutines.


* **`getPerlSubroutines()`:** Returns the list of built-in Perl subroutines.
* **`getSubroutines()`:** Returns the list of user-defined Perl subroutines.
* **`is_sub($sub)`:** Checks if a given name is either a built-in or user-defined subroutine.
* **`addImport($m1, $m2)`:** Adds a Java import statement (package.class).
* **`add_sub($sub)`:** Adds a subroutine to the list of subroutines.
* **`closure_sub()`:** Resets the current subroutine scope (for code outside subs).
* **`add_sub_code($code)`:** Appends Java code to the specified subroutine.
* **`JV_map_call($context, $lstop, $indirob, $listexpr)`:**  A core translation function that handles the conversion of various Perl constructs to Java code.  It specifically handles `open`, `close`, and `print` functions.
* **`JV_GEN_call($context, $lstop, $indirob, $listexpr)`:** Calls `JV_map_call` and adds the generated code to the appropriate subroutine.
* **`addMyVar($var)`:** Adds a Perl `my` variable declaration to the symbol table and internal data structures.
* **`ASSIGNOP($lhs, $rhs)`:** Handles assignment operations.
* **`barestmt($barestmt)`:** Adds a bare statement to the Java code.
* **`generateJavaClass()`:** Generates the complete Java class code, including package, imports, global variables, and methods (subroutines).


## Data Structures

* `$SYMTAB`: A symbol table to store variable information.
* `$CURRENTVAR`: Stores the currently processed variable.
* `perl_sublist`: An array of internal Perl subroutines (`print`, `exit`, etc.).
* `sublist`:  An array storing the list of user defined subroutines.
* `imports`: An array of Java imports.
* `variables`: An array of hashes storing variable information (name, scope, type, value).
* `currentsub`: The name of the subroutine currently being processed.
* `subcode`: A hash containing the Java code for each subroutine.


The module performs semantic translation of Perl code to Java, making assumptions about data types and handling specific Perl functions like `open`, `close`, and `print` in a Java-compatible way.  The generated Java code aims to mirror the functionality of the original Perl code.

